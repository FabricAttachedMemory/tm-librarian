---------------------------------------------------------------------------
L4TM NVM Ecosystem
---------------------------------------------------------------------------

* This is just an initial attempt to clarify deliverables, needs work

These are the NVM related components owned by the L4TM team.

    The delivery points are:

        - TMQ (put a bow around this and replace with QFE when ready)
        - Qemu Fabric Experience (Qemu, res2hot and libpregion replacement)
        - TMAS with GenZ/NVM and Top of Rack Server implemented
        - Real Hardware with GenZ/NVM and Top of Rack Server present

Librarian - aka "Wholesale Memory Broker"

    - python3
    - sqlite3 database
    - json messages
    - L4TM/Debian packaged ?

Librarian Client(s)

    - one per node
    - python3
    - json messages
    - REPL interface
    - FUSE interface
    - L4TM/Debian packaged ?
    - used for initial testing of Librarian
    - used for debugging Librarian going forward

Firewall Manager

    - python3
    - json messages
    - L4TM/Debian packaged ?

Wholesale Filesystem

    - C
    - psuedo filesystem in kernel
    - kernel module
    - L4TM/Debian packaged
    - talks to Librarian using JSON wrapped packages

Aperture Manager

    - C
    - kernel module
    - general GenZ driver
    - L4TM/Debian packaged

Libpregion (or replacement)

    - define functionality required ?

---------------------------------------------------------------------------
Librarian Issues/Questions
---------------------------------------------------------------------------

1. How does the Librarian find out if a node goes down?

2. If a node goes down what does the Librarian do with any shelf reservations belonging to the node?

3. What happens if an NVDIMM board goes down?

---------------------------------------------------------------------------
Style
---------------------------------------------------------------------------

Capture some of the agreed upon coding style decisions.

Python

    - variable naming
    - function comments
    - preamble
    - run pep8 and pylint on code

---------------------------------------------------------------------------
Node/Book registration
---------------------------------------------------------------------------

There will need to be a process for registering books with the Librarian.
Eventually, firmware on each node will supply information to the OS about
NVM being hosted by that node. The node will then contact the librarian
and register the NVM.

Initially, a static file will be used to describe the NVM hosted by each
node. The Librarian will read this file at startup and populate the books
database with the data.

The data file will be in a basic "ini" file format, which can be parsed
using the python3 "configparser" module. The layout will consist of a
section for each node and within each section values for a node ID,
number of books and NVM base address.

Example:

    [node1]
    node_id = 0x0A0A0A0A0A0A0A0A
    num_books = 5
    base_addr = 0x0001000000000000
    [node2]
    node_id = 0x0B0B0B0B0B0B0B0B
    num_books = 5
    base_addr = 0x0002000000000000
    [node3]
    node_id = 0x0C0C0C0C0C0C0C0C
    num_books = 5
    base_addr = 0x0003000000000000
    [node4]
    node_id = 0x0D0D0D0D0D0D0D0D
    num_books = 5
    base_addr = 0x0004000000000000
    [node5]
    node_id = 0x0E0E0E0E0E0E0E0E
    num_books = 5
    base_addr = 0x0005000000000000

Where:

    [node#]     - unique section name
    node_id     - (INT) unique global node ID for SoC
    num_books   - (INT) number of 8GB books hosted by SoC
    base_addr   - (INT) global base address of NVM hosted by SoC

Assumptions:

+ NVM on each node is a continiuous block with respect to GenZ addressing
+ Books are 8GB in length

Issues/Questions:

+ 

---------------------------------------------------------------------------
Debian packaging of Librarian
---------------------------------------------------------------------------

The librarian and all supporting files/documentation should be delivered
in a Debian/hLinux package.

- which files
- where are they delivered

---------------------------------------------------------------------------
Identity Manager
---------------------------------------------------------------------------

Do we need to have some type of identity management function built into the Librarian
for the iterim, to convert node local user/group IDs into a global ID?

---------------------------------------------------------------------------
Testing
---------------------------------------------------------------------------

Each python module with have a "main" section that will have a set of tests
that can be run to verify the basic functionality of the module.

Will also need a set of tests to verify the complete Librarian:

+ Performance - create some test to measure transactions per second or something
  that we can use as a performance baseline. This might include a single client
  issuing commands or multiple clients issuing commands in parallel.

+ Functionality - create a set of commands we can run through the Librarian to
  verify it's working as expected.

+ Errors - create a set of tests to check error/boundary conditions.

---------------------------------------------------------------------------
Librarian server/client design
---------------------------------------------------------------------------

+ Librarian Server (runs on Top-of-Rack Server)

  [Main]   - main python modules,
  [Socket] - initialize/read/write socket
  [TLS]    - wrap socket in TLS
  [JSON]   - convert dictionary to JSAON and back
  [Engine] - receive input from socket, verify and execute commands
  [DB]     - initialize/read/write data to database
  [Books]  - load fake node/book data from file

  [Main] --> [Books]
  [Main] --> [Socket] <--> [JSON] <--> [Engine] <--> [DB]
             [Socket] <--> [TLS]

+ Librarian client(s) (runs on modes)

  [Main]   - main python module, includes either the REPL or FUSE interface
  [REPL]   - read/evaluate/print/loop interface
  [FUSE]   - filesystem interface
  [Engine] - receive input from interface, verify and build commands to send
  [JSON]   - convert dictionary to JSON and back
  [Socket] - initialize/read/write/cleanup socket

  [Main] --> [REPL] or [FUSE] <--> [Engine] <--> [JSON]
                                   [Engine] <--> [Socket]
---------------------------------------------------------------------------
FUSE interface
---------------------------------------------------------------------------

Add a description here of how we'll use the FUSE filesystem as an interface
to the Librarian.

One idea is to start with the FUSE kernel module as a prototype for our
Wholesale Filesystem. It could talk to the FUSE user portion using the existing
protocols which could then talk to the Librarian.

---------------------------------------------------------------------------
Librarian supported commands
---------------------------------------------------------------------------
These will be implemented in the "Engine" module of the Librarian.

"version" - Query Librarian for version information.

    Description:

        +

    Errors:

        +

    Questions/Issues:

        +

    Data in (json):

        { 
            "command":"version"                     # command to execute
        }

    Data out (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"create_shelf" - Create a new shelf.

    Description:

        + new shelf starts with zero books

    Errors:

        +

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"create_shelf"                # command to execute
        }

    Data out (json):

        {
            "shelf_handle":"<INT>",                 # unique handle to identify this shelf
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"open_shelf" - Open an existing shelf.

    Description:

        +

    Errors:

        + shelf does not exist

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"open_shelf",                 # command to execute
            "shelf_handle":"<INT>",                 # shelf handle
            "node_id":"<INT>",                      # node identifier
            "global_user_id":"<INT>",               # global user identifier
            "global_group_id":"<INT>"               # global group identifier
        }

    Data out (json):

        {
            "shelf_handle": "<INT>",                # globally unique handle to identify shelf (zero on error)
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"close_shelf" - Close an existing shelf.

    Description:

        +

    Errors:

        + shelf does not exist

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"close_shelf",                # command to execute
            "shelf_handle":"<INT>",                 # shelf handle
            "node_id":"<INT>",                      # node identifier
            "global_user_id":"<INT>",               # global user identifier
            "global_group_id":"<INT>"               # global group identifier
        }

    Data out (json):

        {
            "shelf_handle": "<INT>",                # globally unique handle to identify shelf (zero on error)
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"destroy_shelf" - Remove shelf

    Description:

        + new shelf starts with zero books

    Errors:

        +

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"destroy_shelf",              # command to execute
            "shelf_handle":"<INT>"                  # shelf handle
        }

    Data out (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"resize_shelf" - Change the size of the NVM available on the shelf.

    Description:

        + add or remove 8GB books to shelf so size has NVM backing
        + if books added/removed talk with firewall

    Errors:

        +

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"resize_shelf",               # command to execute
            "shelf_handle":"<INT>",                 # shelf handle
            "size_bytes":"<INT>"                    # new size of shelf in bytes
        }

    Data out (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"shelf_zaddr" - Request global zaddr for shelf

    Description:

        +

    Errors:

        +

    Questions/Issues:

        + need to understand this one better

    Data in (json):

        {
            "command":"shelf_zaddr",                # command to execute
            "shelf_handle":"<INT>",                 # shelf handle
            "address":"<INT>"                       # faulting address ???
        }

    Data out (json):

        {
            "zaddr":"<INT>",                        # zaddr for book containing faulting address
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"register_firewall" - Register firewall manager for node.

    Description:

        + firewall on node sends this message to register

    Errors:

        +

    Questions/Issues:

        + how does the firewall get the Librarian communication information (hostname and port)

    Data in (json):

        {
            "command":"register_firewall",          # command to execute
            "node_id":"<INT>",                      # node identifier
            "hostname":"<TEXT>",                    # hostname of node for socket communication
            "port":"<INT>"                          # port number for socket communication
        }

    Data out (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"update_firewall" - Update firewall routing tables on node.

    Description:

        + firewall must have registers first before Librarian can send this message
        + the Librarian initiates this command to the Firewall Manager

    Errors:

        +

    Questions/Issues:

        + not sure exactly what information we need to pass to the firewall manager

    Data in (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }

    Data out (json):

        {
            "command":"update_firewall",            # command to execute
            "zaddr":"<INT>",                        # zaddress to add to firewall
            "size_bytes":"<INT>"                    # ??? do we need a range or size for the firewall ???
        }


---------------------------------------------------------------------------
Librarian supported debug commands
---------------------------------------------------------------------------

"list_book" - List book data stored in database.

    Description:

        + 

    Errors:

        + book does not exist given criteria

    Questions/Issues:

        + expand parameters so one or more books can be listed

    Data in (json):

        {
            "command":"list_book",                # command to execute
            "book_handle":"<INT>"                 # Book handle (maybe one for each book you want returned?)
        }

    Data out (json):

        {
            "books":[{book1},{bookN}]"            # data for zero or more books
            "Status":"<INT>"                      # zero for success, otherwise errno
        }


"list_shelf" - List shelf data stored in database.

    Description:

        + 

    Errors:

        + shelf does not exist

    Questions/Issues:

        + expand parameters so one or more books can be listed

    Data in (json):

        {
            "command":"list_shelf",               # command to execute
            "shelf_handle":"<INT>"                # shelf handle (maybe one for each shelf you want returned?)
        }

    Data out (json):

        {
            "shelves":[{shelf1},{shelfN}]"        # data for zero or more shelves
            "status":"<INT>"                      # zero for success, otherwise errno
        }



"list_shelf_reservation" - List shelf reservation data stored in database.

    Description:

        +

    Errors:

        + no reservations exist for shelf

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"list_shelf_reservation",   # command to execture
            "shelf_handle":"<INT>"                # shelf handle (maybe one for each list of shelf reservations you want returned?)
        }

    Data out (json):

        {
            [ShelfResData]                        # TBD - zero or more shelf reservation records ???
            "status":"<INT>"                      # zero for success, otherwise errno
        }

---------------------------------------------------------------------------
Database schema
---------------------------------------------------------------------------

"books" - All available books.

    book_id <INT>          - (primary key) unique ID, maybe the global GenZ address
    status <INT>           - some type of status (zero if unused, used, unavailable or in error?)
    shelf_handle <INT>     - shelf handle for the shelf this book belongs to, zero if free/unused
    sequence <INT>         - order in which this book was added to shelf (1..N) zero if unallocated
    attributes <INT>       - ??? maybe some type of attributes, such as proximity ???
    owner_id <INT>         - ??? maybe a owner ID to track who originally created this shelf ???

    Issues/Comments:

        + assuming a book can only be allocated to one shelf at time
    
"shelves" - All currently allocated shelves.

    shelf_id <INT>         - (primary key) unique ID of some type 
    size_bytes <INT>       - current size in bytes, zero if no books allocated
    book_count <INT>       - current number of books on shelf
    open_count <INT>       - current number of opens
    owner_id <INT>         - ??? maybe an owner ID to track who originally created this shelf ???
    creation_date <INT>    - ??? maybe a date stamp when this shelf was created ???

    Issues/Comments:

        + assuming a shelf can have many users that have it open
        + assuming it's important to track the order in which books where added to shelf, so books can be deleted in LIFO order

"shelf_reservations" - Holds all current shelf reservations.

    reservation_id <INT>   - (primary key) a unique identifier for who has this shelf open (NodeID+GUID+GGID) or process ID, ???
    shelf_id <INT>         - ID of the shelf this reservation is on behalf of
    date_reserved <REAL>   - ??? maybe a date stamp when this shelf was reserved ???

    Issues/Comments:

        + assuming the "open_id" is unique

"firewall_managers" - All currently registered node firewall managers.

    node_id <INT>          - (primary key) unique ID for each node
    host <TEXT>            - hostname for socket communication
    port <INT>             - port number for socket communication
    date_registered <REAL> - ??? maybe a date stamp when this firewall manager registered ???

    Issues/Comments:

        + assuming one firewall manager running on each node
        + assume firewall manager starts up and contacts Librarian with communication information

---------------------------------------------------------------------------
