---------------------------------------------------------------------------
L4TM NVM Ecosystem
---------------------------------------------------------------------------

* This is just an initial attempt to clarify deliverables, needs work

These are the NVM related components owned by the L4TM team.

    The delivery points are:

        - TMQ (put a bow around this and replace with QFE when ready)
        - Qemu Fabric Experience (Qemu, res2hot and libpregion replacement)
        - TMAS with GenZ/NVM and Top of Rack Server implemented
        - Real Hardware with GenZ/NVM and Top of Rack Server present

Librarian - aka "Wholesale Memory Broker"

    - python3
    - sqlite3 database
    - json messages
    - L4TM/Debian packaged ?

Librarian Client(s)

    - one per node
    - python3
    - json messages
    - REPL interface
    - FUSE interface
    - L4TM/Debian packaged ?
    - used for initial testing of Librarian
    - used for debugging Librarian going forward

Firewall Manager

    - python3
    - json messages
    - L4TM/Debian packaged ?

Wholesale Filesystem

    - C
    - psuedo filesystem in kernel
    - kernel module
    - L4TM/Debian packaged
    - talks to Librarian using JSON wrapped packages

Aperture Manager

    - C
    - kernel module
    - general GenZ driver
    - L4TM/Debian packaged

Libpregion (or replacement)

    - define functionality required ?

---------------------------------------------------------------------------
Librarian Issues/Questions
---------------------------------------------------------------------------

1. How does the Librarian find out if a node goes down?

2. If a node goes down what does the Librarian do with any shelf reservations belonging to the node?

3. What happens if an NVDIMM board goes down?

---------------------------------------------------------------------------
Style
---------------------------------------------------------------------------

Capture some of the agreed upon coding style decisions.

Python

    - variable naming
    - function comments
    - preamble
    - run pep8 and pylint on code

---------------------------------------------------------------------------
Node/Book registration
---------------------------------------------------------------------------

There will need to be a process for registering books with the Librarian.
Eventually, firmware on each node will supply information to the OS about
NVM being hosted by that node. The node will then contact the librarian
and register the NVM.

Initially, a static file will be used to describe the NVM hosted by each
node. The Librarian will read this file at startup and populate the books
database with the data.

The data file will be in a basic "ini" file format, which can be parsed
using the python3 "configparser" module. The layout will consist of a
global section which lists the total number of nodes and a book size, then
a section for each node which lists the node ID, total NVM size and LZA base
address for the NVM.

Example:

    [global]
    node_cnt = 5
    book_size = 8G
    [node01]
    node_id = 0x0A0A0A0A0A0A0A0A
    lza_base = 0x0000000000000000
    nvm_size = 64G
    [node02]
    node_id = 0x0B0B0B0B0B0B0B0B
    lza_base = 0x0000001000000000
    nvm_size = 64G
    [node03]
    node_id = 0x0C0C0C0C0C0C0C0C
    lza_base = 0x0000002000000000
    nvm_size = 64G
    [node04]
    node_id = 0x0D0D0D0D0D0D0D0D
    lza_base = 0x0000003000000000
    nvm_size = 64G
    [node05]
    node_id = 0x0E0E0E0E0E0E0E0E
    lza_base = 0x0000004000000000
    nvm_size = 64G

Where:

    [global]    - (STR) global section name
    node_cnt    - (INT) total number of nodes
    book_size   - (INT) book size (M = Megabytes and G = Gigabytes)
    [node##]    - (STR) unique section name
    node_id     - (INT) unique global node ID for SoC
    lza_base    - (INT) logical GenZ base address for NVM hosted by node
    nvm_size    - (INT) total size of NVM hosted by node

Assumptions:

    + NVM on each node is a continiuous block with respect to GenZ addressing
    + "node_cnt" matches the number of "[node#]" sections present in file
    + "nvm_size" is a multiple of "book_size"
    + nodes are in increasing order based on "lza_base"
    + "lza_base" plus "nvm_size" does not overlap next node "lza_base"
    + there can be gaps between the end of one nodes NVM and the start of another nodes NVM

---------------------------------------------------------------------------
Debian packaging of Librarian
---------------------------------------------------------------------------

The librarian and all supporting files/documentation should be delivered
in a Debian/hLinux package.

- which files
- where are they delivered

---------------------------------------------------------------------------
Identity Manager
---------------------------------------------------------------------------

Do we need to have some type of identity management function built into the Librarian
for the iterim, to convert node local user/group IDs into a global ID?

---------------------------------------------------------------------------
Testing
---------------------------------------------------------------------------

Each python module with have a "main" section that will have a set of tests
that can be run to verify the basic functionality of the module.

Will also need a set of tests to verify the complete Librarian:

+ Performance - create some test to measure transactions per second or something
  that we can use as a performance baseline. This might include a single client
  issuing commands or multiple clients issuing commands in parallel.

+ Functionality - create a set of commands we can run through the Librarian to
  verify it's working as expected.

+ Errors - create a set of tests to check error/boundary conditions.

---------------------------------------------------------------------------
Librarian server/client design
---------------------------------------------------------------------------

+ Librarian Server (runs on Top-of-Rack Server)

  [Main]   - main python modules,
  [Socket] - initialize/read/write socket
  [TLS]    - wrap socket in TLS
  [JSON]   - convert dictionary to JSAON and back
  [Engine] - receive input from socket, verify and execute commands
  [DB]     - initialize/read/write data to database
  [Books]  - load fake node/book data from file

  [Main] --> [Books]
  [Main] --> [Socket] <--> [JSON] <--> [Engine] <--> [DB]
             [Socket] <--> [TLS]

+ Librarian client(s) (runs on modes)

  [Main]   - main python module, includes either the REPL or FUSE interface
  [REPL]   - read/evaluate/print/loop interface
  [FUSE]   - filesystem interface
  [Engine] - receive input from interface, verify and build commands to send
  [JSON]   - convert dictionary to JSON and back
  [Socket] - initialize/read/write/cleanup socket

  [Main] --> [REPL] or [FUSE] <--> [Engine] <--> [JSON]
                                   [Engine] <--> [Socket]
---------------------------------------------------------------------------
FUSE interface
---------------------------------------------------------------------------

Add a description here of how we'll use the FUSE filesystem as an interface
to the Librarian.

One idea is to start with the FUSE kernel module as a prototype for our
Wholesale Filesystem. It could talk to the FUSE user portion using the existing
protocols which could then talk to the Librarian.

---------------------------------------------------------------------------
Librarian supported commands
---------------------------------------------------------------------------
These will be implemented in the "Engine" module of the Librarian.

"version" - Query Librarian for version information.

    Description:

        +

    Errors:

        +

    Questions/Issues:

        +

    Data in (json):

        { 
            "command":"version"                     # command to execute
        }

    Data out (json):

        {
            "status":"<INT>",                       # zero for success, otherwise errno
            "version":"<STR>"                       # librarian version string
        }


"shelf_create" - Create a new shelf.

    Description:

        + new shelf starts with zero books

    Errors:

        +

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"shelf_create"                # command to execute
            "shelf_owner":"<INT>"                   # node_id + user id + group id? or a global id?
        }

    Data out (json):

        {
            "status":"<INT>",                       # zero for success, otherwise errno
            "shelf_handle":"<INT>"                  # unique handle to identify this shelf, zero on error
        }


"shelf_open" - Reserve/Open an existing shelf for use.

    Description:

        + increment shelf open count
        + create shelf reservation

    Errors:

        + shelf does not exist

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"shelf_open",                 # command to execute
            "shelf_handle":"<INT>",                 # unique handle to identify this shelf, zero on error
            "reservation_owner":"<INT>"             # node_id + user id + group id? or a global id?
        }

    Data out (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"shelf_close" - Close an existing shelf.

    Description:

        + decrement shelf open count
        + delete shelf reservation

    Errors:

        + shelf does not exist

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"close_shelf",                # command to execute
            "shelf_handle":"<INT>",                 # shelf handle
            "node_id":"<INT>",                      # node identifier
            "global_user_id":"<INT>",               # global user identifier
            "global_group_id":"<INT>"               # global group identifier
        }

    Data out (json):

        {
            "shelf_handle": "<INT>",                # globally unique handle to identify shelf (zero on error)
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"shelf_destroy" - Remove shelf

    Description:

        + remove shelf
        + free any existing books on shelf?
        + delete any shelf reservations?
        + OR should the destroy fail if the open count is greater than zero

    Errors:

        +

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"shelf_destroy",              # command to execute
            "shelf_handle":"<INT>"                  # shelf handle
        }

    Data out (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"shelf_resize" - Change the size of the NVM available on the shelf.

    Description:

        + add or remove 8GB books to shelf so size has NVM backing
        + if books added/removed talk with firewall

    Errors:

        +

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"shelf_resize",               # command to execute
            "shelf_handle":"<INT>",                 # shelf handle
            "size_bytes":"<INT>"                    # new size of shelf in bytes
        }

    Data out (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"shelf_zaddr" - Request global zaddr for shelf

    Description:

        +

    Errors:

        +

    Questions/Issues:

        + need to understand this one better

    Data in (json):

        {
            "command":"shelf_zaddr",                # command to execute
            "shelf_handle":"<INT>",                 # shelf handle
            "address":"<INT>"                       # faulting address ???
        }

    Data out (json):

        {
            "zaddr":"<INT>",                        # zaddr for book containing faulting address
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"firewall_register" - Register firewall manager for node.

    Description:

        + firewall on node sends this message to register

    Errors:

        +

    Questions/Issues:

        + how does the firewall get the Librarian communication information (hostname and port)

    Data in (json):

        {
            "command":"firewall_register",          # command to execute
            "node_id":"<INT>",                      # node identifier
            "hostname":"<TEXT>",                    # hostname of node for socket communication
            "port":"<INT>"                          # port number for socket communication
        }

    Data out (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }


"firewall_update" - Update firewall routing tables on node.

    Description:

        + firewall must have registered first before Librarian can send this message
        + the Librarian initiates this command to the Firewall Manager

    Errors:

        +

    Questions/Issues:

        + not sure exactly what information we need to pass to the firewall manager

    Data in (json):

        {
            "status":"<INT>"                        # zero for success, otherwise errno
        }

    Data out (json):

        {
            "command":"firewall_update",            # command to execute
            "zaddr":"<INT>",                        # zaddress to add to firewall
            "size_bytes":"<INT>"                    # ??? do we need a range or size for the firewall ???
        }


---------------------------------------------------------------------------
Librarian supported debug commands
---------------------------------------------------------------------------

"book_list" - List book data stored in database.

    Description:

        + maybe a list of book handles to list, if book_handle == 0 then return them all?

    Errors:

        + book does not exist given criteria

    Questions/Issues:

        + expand parameters so one or more books can be listed

    Data in (json):

        {
            "command":"book_list",                # command to execute
            "book_handle":"<INT>"                 # Book handle (maybe one for each book you want returned?)
        }

    Data out (json):

        {
            "books":[{book1},{bookN}]"            # data for zero or more books
            "Status":"<INT>"                      # zero for success, otherwise errno
        }


"shelf_list" - List shelf data stored in database.

    Description:

        +  maybe a list of shelf handles to list, if shelf_handle == 0 then return them all?

    Errors:

        + shelf does not exist

    Questions/Issues:

        + expand parameters so one or more books can be listed

    Data in (json):

        {
            "command":"shelf_list",               # command to execute
            "shelf_handle":"<INT>"                # shelf handle (maybe one for each shelf you want returned?)
        }

    Data out (json):

        {
            "shelves":[{shelf1},{shelfN}]"        # data for zero or more shelves
            "status":"<INT>"                      # zero for success, otherwise errno
        }


"shelf_reservation_list" - List shelf reservation data stored in database.

    Description:

        +

    Errors:

        + no reservations exist for shelf

    Questions/Issues:

        +

    Data in (json):

        {
            "command":"shelf_reservation_list",   # command to execture
            "shelf_handle":"<INT>"                # shelf handle (maybe one for each list of shelf reservations you want returned?)
        }

    Data out (json):

        {
            [ShelfResData]                        # TBD - zero or more shelf reservation records ???
            "status":"<INT>"                      # zero for success, otherwise errno
        }

---------------------------------------------------------------------------
Database schema
---------------------------------------------------------------------------

"books" - All available books

    book_id <INT>          - (primary key) unique identifier for book (LZA address?)
    node_id <INT>          - unique ID for each SoC node
    status <INT>           - status of book (0 = unused, 1 = used in shelf(s))
    attributes <INT>       - ??? maybe some type of attributes, such as proximity ???
    size_bytes <INT>       - book size in bytes

    Assumptions:
        +
    
"shelves" - All currently allocated shelves

    shelf_id <INT>         - (primary key) unique identifier for shelf
    size_bytes <INT>       - current size in bytes, zero if no books allocated
    book_count <INT>       - current number of books on shelf
    open_count <INT>       - current number of opens
    c_time <REAL>          - creation time of shelf
    m_time <REAL>          - last modification time of shelf

    Assumptions:
        + a shelf can have many users that have it open
        + it's important to track the order in which books where added to shelf, so books can be deleted in LIFO order

"books_on_shelf" - All books allocated to shelves

    shelf_id <INT>         - a unique identifier for shelf
    book_id <INT>          - unique identifier for book (LZA address?)
    seq_num <INT>          - order number in which this book was added to shelf (1..N)

    Assumptions:
        + a book can be used on one or more shelves
        + a book can be used more than once on a shelf

---------------------------------------------------------------------------
